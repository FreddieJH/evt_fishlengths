---
title: "Extreme Value Theory"
author: "Freddie J. Heather"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(evd)
library(patchwork)
library(geomtextpath)
```


# Background

Extreme Value Theory (EVT) is a branch of statistics that focuses on the extreme deviations from the median of probability distributions. Traditionally, EVT has been applied in fields such as hydrology, finance, and environmental sciences to model and predict rare events, such as floods, market crashes, and extreme weather conditions.

In this analysis, we extend the application of EVT to estimate the maximum lengths of fish species. While previous studies, such as Formacion et al. (1991), have utilized the Gumbel distribution for this purpose, we aim to incorporate the broader Extreme Value Distribution (EVD) framework. This approach allows for a more comprehensive analysis by considering different types of extreme value distributions, including the Gumbel, FrÃ©chet, and Weibull distributions.

The Generalized Extreme Value (GEV) distribution is defined as:

$$
G(x; \mu, \sigma, \xi) = exp(-[1 + \xi(\frac{x-\mu}{\sigma})]^{-1/\xi})
$$

where:

$\mu$ is the location parameter,
$\sigma$ is the scale parameter,
$\xi$ is the shape parameter.

By applying the GEV distribution, we can better estimate the maximum lengths of fish species, providing valuable insights for ecological and biological studies.

The Gumbel distribution is a simplified variation of the GEV distribution where $\xi = 0$


# GEV

The shape of the GEV distribution is defined by the shape ($\xi$) parameter. Below, location ($\mu$) is fixed at zero, and scale ($\sigma$) is fixed at one.

```{r}

tibble(x = seq(-4, 4, by = 0.001)) %>% 
  mutate(shape_0 = dgev(x = x, loc=0, scale=1, shape=0),
         shape_neghalf = dgev(x = x, loc=0, scale=1, shape=-0.5),
         shape_half = dgev(x = x, loc=0, scale=1, shape=0.5)) %>% 
  pivot_longer(cols = contains("shape_")) %>% 
  filter(value > 0) %>% 
  ggplot() +
  aes(x = x, y = value, col = name) +
  geom_path() +
  labs(x = "x", 
       y = "Density", 
       col = element_blank(), 
       title = "GEV distribution with varying shape parameter") +
  scale_color_discrete(label = c(shape_0 = expression(paste(~xi, " = 0")),
                                 shape_half = expression(paste(~xi, " = 1/2")),
                                 shape_neghalf = expression(paste(~xi, " = -1/2")))) +
  theme_classic(20)

```


# Simulation

Testing GEV with simulated data. Given 100 normal distributions ($\mu$ = 0, $\sigma$ = 1), each of size 1000, we take the maxima of those distributions and look at the distribution of those maxima. 

```{r}

tibble(sample_number = 1:100) %>%
  expand_grid(sample_id = 1:1000) %>% 
  mutate(x = rnorm(n = 100*1000)) %>% 
  summarise(sample_maxima = max(x), 
            .by = sample_number) %>% 
  ggplot(aes(x = sample_maxima)) +
  geom_density() +
  labs(x = "Sample Maxima", 
       y = "Density", 
       title = "Distribution of sample maxima (n = 100)") +
  theme_classic(20)


```


Since there is variation in the sampling, we can run this multiple times, each with a new seed, to see how much variation there is. 

```{r}

for(seed in 1:100){
  
  if(seed == 1) out_tab <- tibble()
  
  set.seed(seed)
  
  tab <- 
    tibble(sample_number = 1:100) %>%
    expand_grid(sample_id = 1:1000) %>% 
    mutate(x = rnorm(n = 100*1000)) %>% 
    summarise(sample_maxima = max(x), 
              .by = sample_number) %>% 
    mutate(seed = seed)
  
  out_tab <- 
    bind_rows(
      out_tab, 
      tab
    )
  
}

out_tab %>% 
  ggplot(aes(x = sample_maxima, 
             group = seed)) +
  geom_density(colour=alpha("red", 0.3)) +
  labs(x = "Sample Maxima", 
       y = "Density", 
       title = "Distribution of sample maxima (n = 100)", 
       subtitle = "Repeated 100 times") +
  theme_classic(20)


```

## Fitting GEV to maxima

```{r}

gev_fits <- 
  out_tab %>% 
  nest(.by = seed) %>% 
  mutate(gev_fit = map(.x = data, 
                       .f = ~evd::fgev(.x$sample_maxima)), 
         loc = map_dbl(.x = gev_fit,
                       .f = ~.x$estimate["loc"]),
         scale = map_dbl(.x = gev_fit,
                         .f = ~.x$estimate["scale"]),
         shape = map_dbl(.x = gev_fit,
                         .f = ~.x$estimate["shape"])) 
# lm <- out_tab %>% 
#   filter(seed == 1) %>% 
#   pull(sample_maxima)
# extRemes::fevd(lm)
# evd::fgev(lm)


gev_fits2 <- 
  out_tab %>% 
  nest(.by = seed) %>% 
  mutate(gev_fit = map(.x = data, 
                       .f = ~extRemes::fevd(.x$sample_maxima)), 
         loc = map_dbl(.x = gev_fit,
                       .f = ~.x$estimate["loc"]),
         scale = map_dbl(.x = gev_fit,
                         .f = ~.x$estimate["scale"]),
         shape = map_dbl(.x = gev_fit,
                         .f = ~.x$estimate["shape"])) 


median_gev_fits <-
  gev_fits %>% 
  summarise(med_loc = median(loc), 
            med_scale = median(scale), 
            med_shape = median(shape))


median_gev_ests <- 
  tibble(x = seq(min(out_tab$sample_maxima), 
                 max(out_tab$sample_maxima), 
                 by = 0.001), 
         y = dgev(x = x, 
                  loc = median_gev_fits$med_loc, 
                  scale = median_gev_fits$med_scale,
                  shape = median_gev_fits$med_shape))

ci_gev_ests <- 
  gev_fits %>% 
  select(seed, loc, scale, shape) %>% 
  expand_grid(x = seq(min(out_tab$sample_maxima), 
                      max(out_tab$sample_maxima), 
                      by = 0.001)) %>% 
  rowwise() %>%
  mutate(y = dgev(x = x, 
                  loc = loc, 
                  scale = scale,
                  shape = shape)) %>% 
  ungroup() %>% 
  summarise(
    median = quantile(y, p = 0.5),
    lower = quantile(y, p = 0.025),
    upper = quantile(y, p = 0.975), 
    .by = x
  )



out_tab %>% 
  ggplot(aes(x = sample_maxima, 
             group = seed)) +
  geom_density(colour=alpha("red", 0.3)) +
  
  geom_ribbon(inherit.aes = FALSE, 
              aes(x = x, ymax = upper, ymin = lower), 
              data = ci_gev_ests, 
              linewidth = 1, 
              alpha = 0.3) +
  geom_line(inherit.aes = FALSE, 
            aes(x = x, y = median), 
            data = ci_gev_ests, 
            linewidth = 1) +
  labs(x = "Sample Maxima", 
       y = "Density", 
       title = "Distribution of sample maxima (n = 100)", 
       subtitle = "Repeated 100 times") +
  theme_classic(20)

```

# Comparison to truth

- Sampling from a normal distribution with a mean of 50cm and sd = 50/3
- true population size is 10,000
- sample size is 100
- 10 samples are taken
- we need to repeat it to get the error around the estimate

```{r}

for(const_sample_size in c(10, 100, 100, 10000)){
  for(rep in 1:20){
    
    if(file.exists(paste0("evt_plots/ss", const_sample_size, "_", rep, ".png"))) next
    
    true_population_size <-  1000000
    num_samples <- 10
    sample_sizes <- sample(5:200, num_samples, replace = TRUE)
    sample_sizes <- rep(const_sample_size, num_samples)
    # pred_percentile <- 0.99
    pred_percentile <- num_samples/(num_samples+1)
    
    # Function to simulate fish sizes and extract maxima
    simulate_fish_maxima <- function(num_samples, sample_sizes) {
      maxima <- numeric(num_samples)
      
      for (i in 1:num_samples) {
        # Generate random fish sizes for each sample
        fish_sizes <- sample(true_population, sample_sizes[i])
        # Extract the maximum fish size from each sample
        maxima[i] <- max(fish_sizes)
      }
      
      return(maxima)
    }
    
    
    # Simulate a large population to find the 'true' max value
    true_population <- rnorm(true_population_size, mean = 50, sd = 10)
    true_max_value <- max(true_population)
    true_p99_value <- quantile(true_population, 0.99)
    
    
    # Simulate fish size maxima
    fish_maxima <- simulate_fish_maxima(num_samples, sample_sizes)
    
    gev_fit <- suppressWarnings(try(evd::fgev(x = fish_maxima),
                                    silent = TRUE))
    
    if(sum(class(gev_fit) == "try-error")) next
    
    # Estimate the maximum length of the true population (e.g., 100-year return level)
    return_level <- qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3])
    
    
    
    # Plot the results for visualization
    p1 <- ggplot() +
      geom_density(aes(x), data = tibble(x = true_population)) +
      geom_rug(aes(x = fish_maxima, alpha = sample_sizes), color = "purple", length = unit(1.5, units = "cm")) +
      geom_textvline(aes(xintercept = return_level), color = "red", linetype = "dashed", label = "Est LMAX") +
      geom_textvline(aes(xintercept = true_max_value), color = "blue", linetype = "dashed", label = "True LMAX") +
      geom_textvline(aes(xintercept = true_p99_value), color = "orange", linetype = "dashed", label = "True 99th perc") +
      labs(title = "Comparison of Estimated Max Value and True Max Value",
           x = "Fish Size",
           y = "Frequency") +
      theme_minimal()
    
    
    plot_data <-
      tibble(ss = sample_sizes, 
             max = fish_maxima, 
             rank = rank(fish_maxima), 
             pos = rank/(max(rank)+1)) 
    
    p2 <-
      tibble(x = seq(1, max(true_max_value, return_level), by = 0.1)) %>% 
      mutate(pgev = pgev(q = x, 
                         loc = gev_fit$estimate[1], 
                         scale = gev_fit$estimate[2],
                         shape = gev_fit$estimate[3])) %>% 
      ggplot() +
      geom_point(aes(x = max, y = pos, alpha = ss), color = "purple", 
                 plot_data) +
      geom_line(aes(x = x, y = pgev)) +
      # geom_hline(yintercept = pred_percentile) +
      theme_minimal()
    
    
    p3 <- p1+p2 + plot_layout(ncol = 1)
    
    
    ggsave(plot = p3, filename = paste0("evt_plots/ss", const_sample_size, "_", rep, ".png"))
  }
}


```


The greater your sample size to calculate your maxima, the more likely you are to have larger numbers. This is equivalent to a local fishing competitions vs regional ones. The regional ones are likely to have bigger length maxima since they are taking a greater sample of the true underlying population. This is true even when the number of maxima (i.e., remains constant).

The next question, is how much does the true population size impactthe results?

```{r}

for(true_pop in c(1e4, 1e5, 1e6)){
  for(const_sample_size in c(10, 100, 100, 1000)){
    for(rep in 1:20){
      
      if(file.exists(paste0("evt_plots/true", true_pop, "_ss", const_sample_size, "_rep", rep, ".png"))) next
      
      true_population_size <-  1000000
      num_samples <- 10
      sample_sizes <- sample(5:200, num_samples, replace = TRUE)
      sample_sizes <- rep(const_sample_size, num_samples)
      # pred_percentile <- 0.99
      pred_percentile <- num_samples/(num_samples+1)
      
      # Function to simulate fish sizes and extract maxima
      simulate_fish_maxima <- function(num_samples, sample_sizes) {
        maxima <- numeric(num_samples)
        
        for (i in 1:num_samples) {
          # Generate random fish sizes for each sample
          fish_sizes <- sample(true_population, sample_sizes[i])
          # Extract the maximum fish size from each sample
          maxima[i] <- max(fish_sizes)
        }
        
        return(maxima)
      }
      
      
      # Simulate a large population to find the 'true' max value
      true_population <- rnorm(true_population_size, mean = 50, sd = 10)
      true_max_value <- max(true_population)
      true_p99_value <- quantile(true_population, 0.99)
      
      
      # Simulate fish size maxima
      fish_maxima <- simulate_fish_maxima(num_samples, sample_sizes)
      
      gev_fit <- suppressWarnings(try(evd::fgev(x = fish_maxima),
                                      silent = TRUE))
      
      if(sum(class(gev_fit) == "try-error")) next
      
      # Estimate the maximum length of the true population (e.g., 100-year return level)
      return_level <- qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3])
      
      
      
      # Plot the results for visualization
      p1 <- ggplot() +
        geom_density(aes(x), data = tibble(x = true_population)) +
        geom_rug(aes(x = fish_maxima, alpha = sample_sizes), color = "purple", length = unit(1.5, units = "cm")) +
        geom_textvline(aes(xintercept = return_level), color = "red", linetype = "dashed", label = "Est LMAX") +
        geom_textvline(aes(xintercept = true_max_value), color = "blue", linetype = "dashed", label = "True LMAX") +
        geom_textvline(aes(xintercept = true_p99_value), color = "orange", linetype = "dashed", label = "True 99th perc") +
        labs(title = "Comparison of Estimated Max Value and True Max Value",
             x = "Fish Size",
             y = "Frequency") +
        theme_minimal()
      
      
      plot_data <-
        tibble(ss = sample_sizes, 
               max = fish_maxima, 
               rank = rank(fish_maxima), 
               pos = rank/(max(rank)+1)) 
      
      p2 <-
        tibble(x = seq(1, max(true_max_value, return_level), by = 0.1)) %>% 
        mutate(pgev = pgev(q = x, 
                           loc = gev_fit$estimate[1], 
                           scale = gev_fit$estimate[2],
                           shape = gev_fit$estimate[3])) %>% 
        ggplot() +
        geom_point(aes(x = max, y = pos, alpha = ss), color = "purple", 
                   plot_data) +
        geom_line(aes(x = x, y = pgev)) +
        # geom_hline(yintercept = pred_percentile) +
        theme_minimal()
      
      
      p3 <- p1+p2 + plot_layout(ncol = 1)
      
      
      ggsave(plot = p3, filename = paste0("evt_plots/true", true_pop, "_ss", const_sample_size, "_rep", rep, ".png"))
    }
  }
}
```

Underlying population size doesn't really matter, it is the sample size that is important. What about if we vary the sample size from which the maxima are taken?


```{r}

for(true_pop in c(1e4, 1e5, 1e6)){
  # for(const_sample_size in c(10, 100, 100, 1000)){
  for(rep in 1:20){
    
    
    
    true_population_size <-  1000000
    num_samples <- 10
    sample_sizes <- sample(10:1000, num_samples, replace = TRUE)
    # pred_percentile <- 0.99
    pred_percentile <- num_samples/(num_samples+1)
    
    # Function to simulate fish sizes and extract maxima
    simulate_fish_maxima <- function(num_samples, sample_sizes) {
      maxima <- numeric(num_samples)
      
      for (i in 1:num_samples) {
        # Generate random fish sizes for each sample
        fish_sizes <- sample(true_population, sample_sizes[i])
        # Extract the maximum fish size from each sample
        maxima[i] <- max(fish_sizes)
      }
      
      return(maxima)
    }
    
    mean_ss <- round(mean(sample_sizes))
    
    if(file.exists(paste0("evt_plots/variable sample size/true", true_pop, "_meanss", mean_ss, "_rep", rep, ".png"))) next
    # Simulate a large population to find the 'true' max value
    true_population <- rnorm(true_population_size, mean = 50, sd = 10)
    true_max_value <- max(true_population)
    true_p99_value <- quantile(true_population, 0.99)
    
    
    # Simulate fish size maxima
    fish_maxima <- simulate_fish_maxima(num_samples, sample_sizes)
    
    gev_fit <- suppressWarnings(try(evd::fgev(x = fish_maxima),
                                    silent = TRUE))
    
    if(sum(class(gev_fit) == "try-error")) next
    
    # Estimate the maximum length of the true population (e.g., 100-year return level)
    return_level <- qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3])
    
    
    
    # Plot the results for visualization
    p1 <- ggplot() +
      geom_density(aes(x), data = tibble(x = true_population)) +
      geom_rug(aes(x = fish_maxima, alpha = sample_sizes), color = "purple", length = unit(1.5, units = "cm")) +
      geom_textvline(aes(xintercept = return_level), color = "red", linetype = "dashed", label = "Est LMAX") +
      geom_textvline(aes(xintercept = true_max_value), color = "blue", linetype = "dashed", label = "True LMAX") +
      geom_textvline(aes(xintercept = true_p99_value), color = "orange", linetype = "dashed", label = "True 99th perc") +
      labs(title = "Comparison of Estimated Max Value and True Max Value",
           x = "Fish Size",
           y = "Frequency") +
      theme_minimal()
    
    
    plot_data <-
      tibble(ss = sample_sizes, 
             max = fish_maxima, 
             rank = rank(fish_maxima), 
             pos = rank/(max(rank)+1)) 
    
    p2 <-
      tibble(x = seq(1, max(true_max_value, return_level), by = 0.1)) %>% 
      mutate(pgev = pgev(q = x, 
                         loc = gev_fit$estimate[1], 
                         scale = gev_fit$estimate[2],
                         shape = gev_fit$estimate[3])) %>% 
      ggplot() +
      geom_point(aes(x = max, y = pos, alpha = ss), color = "purple", 
                 plot_data) +
      geom_line(aes(x = x, y = pgev)) +
      # geom_hline(yintercept = pred_percentile) +
      theme_minimal()
    
    
    p3 <- p1+p2 + plot_layout(ncol = 1)
    
    
    ggsave(plot = p3, 
           filename = paste0("evt_plots/variable sample size/true", true_pop, "_meanss", mean_ss, "_rep", rep, ".png"))
  }
  # }
}


```

# How many samples would be need to get a good estimate of LMAX?

```{r}

plot_maxima <- function(tps, ns, ss, pp = 0.99){


true_population_size <-  tps
num_samples <- ns
sample_sizes <- rep(ss, num_samples)
# sample_sizes <- sample(10:1000, num_samples, replace = TRUE)
# pred_percentile <- 0.99
pred_percentile <- pp
pred_percentile <- num_samples/(num_samples+1)

# Function to simulate fish sizes and extract maxima
simulate_fish_maxima <- function(num_samples, sample_sizes) {
  maxima <- numeric(num_samples)
  
  for (i in 1:num_samples) {
    # Generate random fish sizes for each sample
    fish_sizes <- sample(true_population, sample_sizes[i])
    # Extract the maximum fish size from each sample
    maxima[i] <- max(fish_sizes)
  }
  
  return(maxima)
}


# Simulate a large population to find the 'true' max value
true_population <- rnorm(true_population_size, mean = 50, sd = 10)
true_max_value <- max(true_population)
true_p99_value <- quantile(true_population, 0.99)


# Simulate fish size maxima
fish_maxima <- simulate_fish_maxima(num_samples, sample_sizes)

gev_fit <- suppressWarnings(try(evd::fgev(x = fish_maxima),
                                silent = TRUE))


# Estimate the maximum length of the true population (e.g., 100-year return level)
return_level <- qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3])



# Plot the results for visualization
p1 <- ggplot() +
  geom_density(aes(x), data = tibble(x = true_population)) +
  geom_rug(aes(x = fish_maxima, alpha = sample_sizes), color = "purple", length = unit(1.5, units = "cm")) +
  geom_textvline(aes(xintercept = return_level), color = "red", linetype = "dashed", label = "Est LMAX") +
  geom_textvline(aes(xintercept = true_max_value), color = "blue", linetype = "dashed", label = "True LMAX") +
  geom_textvline(aes(xintercept = true_p99_value), color = "orange", linetype = "dashed", label = "True 99th perc") +
  labs(title = "Comparison of Estimated Max Value and True Max Value",
       x = "Fish Size",
       y = "Frequency") +
  theme_minimal()


plot_data <-
  tibble(ss = sample_sizes, 
         max = fish_maxima, 
         rank = rank(fish_maxima), 
         pos = rank/(max(rank)+1)) 

p2 <-
  tibble(x = seq(1, max(true_max_value, return_level), by = 0.1)) %>% 
  mutate(pgev = pgev(q = x, 
                     loc = gev_fit$estimate[1], 
                     scale = gev_fit$estimate[2],
                     shape = gev_fit$estimate[3])) %>% 
  ggplot() +
  geom_point(aes(x = max, y = pos, alpha = ss), color = "purple", 
             plot_data) +
  geom_line(aes(x = x, y = pgev)) +
  # geom_hline(yintercept = pred_percentile) +
  theme_minimal()


return(p1+p2 + plot_layout(ncol = 1))

}


plot_maxima(tps = 1000000, 
            ns = 1000, 
            ss = 10) %>% 
    ggsave(filename = "evt_plots/ns1000_ss10.png")

plot_maxima(tps = 1000000, 
            ns = 10, 
            ss = 1000) %>% 
    ggsave(filename = "evt_plots/ns10_ss1000.png")

plot_maxima(tps = 1000000, 
            ns = 10, 
            ss = 10000) %>% 
    ggsave(filename = "evt_plots/ns10_ss10000.png")

plot_maxima(tps = 10000, 
            ns = 10, 
            ss = 8000) %>% 
    ggsave(filename = "evt_plots/tps10k_ns10_ss9k.png")

```


# Sample size as proportion of true population size

```{r}


get_return <- function(tps, ns, ss, pp = 0.99){


true_population_size <-  tps
num_samples <- ns
sample_sizes <- rep(ss, num_samples)
# sample_sizes <- sample(10:1000, num_samples, replace = TRUE)
# pred_percentile <- 0.99
pred_percentile <- pp
pred_percentile <- num_samples/(num_samples+1)

# Function to simulate fish sizes and extract maxima
simulate_fish_maxima <- function(num_samples, sample_sizes) {
  maxima <- numeric(num_samples)
  
  for (i in 1:num_samples) {
    # Generate random fish sizes for each sample
    fish_sizes <- sample(true_population, sample_sizes[i])
    # Extract the maximum fish size from each sample
    maxima[i] <- max(fish_sizes)
  }
  
  return(maxima)
}


# Simulate a large population to find the 'true' max value
true_population <- rnorm(true_population_size, mean = 50, sd = 10)
true_max_value <- max(true_population)
true_p99_value <- quantile(true_population, 0.99)


# Simulate fish size maxima
fish_maxima <- simulate_fish_maxima(num_samples, sample_sizes)

gev_fit <- suppressWarnings(try(evd::fgev(x = fish_maxima),
                                silent = TRUE))

if(inherits(gev_fit, "try-error")) return(tibble(loc = 0, scale = 0, shape = 0, qgev = 0))
# Estimate the maximum length of the true population (e.g., 100-year return level)
return_level <- 
  qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3]) %>% 
  as.numeric()

# return(return_level)
return(tibble(loc = gev_fit$estimate[1],
              scale = gev_fit$estimate[2],
              shape = gev_fit$estimate[3],
              qgev = qgev(pred_percentile, loc = gev_fit$estimate[1], scale = gev_fit$estimate[2], shape = gev_fit$estimate[3])))

}

library(parallel)
library(multidplyr)
detectCores()
cluster <- new_cluster(6)
cluster_library(cluster, "purrr")
cluster_copy(cluster, "get_return")
cluster_copy(cluster, "qgev")
cluster_copy(cluster, "tibble")
t1 <- Sys.time()
sim_byprop_4 <- 
  tibble(tps = c(1e4, 1e5, 1e6)) %>% 
  expand_grid(ss_const = 
                c(
                  seq(0.05, 0.5, by = 0.05),
                  seq(0.01, 0.05, by = 0.01),
                seq(0.001, 0.01, by = 0.001)
                )) %>% 
  expand_grid(ns = 10) %>% 
  # expand_grid(ns = c(10, 20, 50, 100, 1000)) %>% 
  mutate(ss = tps*ss_const) %>% 
  rowid_to_column(var = "sim_id") %>% 
  nest(.by = sim_id) %>% 
  partition(cluster) %>%
  mutate(out = map(.x = data, 
                   .f = ~get_return(tps = .x$tps, 
            ns = .x$ns, 
            ss = .x$ss))) %>% 
  collect() %>% 
  unnest(cols = c(data, out)) 
time_cluster6 <- Sys.time() - t1

time_cluster6
time_normal


t1 <- Sys.time()
sim_byprop_4 <- 
  tibble(tps = c(1e4, 1e5, 1e6)) %>% 
  expand_grid(ss_const = 
                c(
                  seq(0.05, 0.5, by = 0.05),
                  seq(0.01, 0.05, by = 0.01),
                seq(0.001, 0.01, by = 0.001)
                )) %>% 
  expand_grid(ns = c(10, 20, 30)) %>% 
  mutate(ss = tps*ss_const) %>% 
  rowid_to_column(var = "sim_id") %>% 
  nest(.by = sim_id) %>% 
  # partition(cluster) %>%
  mutate(out = map(.x = data, 
                   .f = ~get_return(tps = .x$tps, 
            ns = .x$ns, 
            ss = .x$ss))) %>% 
  # collect() %>% 
  unnest(cols = c(data, out)) 
time_normal <- Sys.time() - t1



get_return(tps = 10000, 
            ns = 10, 
            ss = 1500)

sim_byprop_1 %>% 
  bind_rows(sim_byprop_2) %>% 
  bind_rows(sim_byprop_3) %>% 
  filter(qgev < 150, qgev > 10) %>% 
  ggplot(aes(ss_const, qgev, col = as.factor(tps))) +
  geom_point() +
  stat_smooth()

sim_byprop_4 %>% 
  filter(qgev < 150, qgev > 10) %>% 
  filter(ss < 5e4) %>% 
  ggplot(aes(ss, qgev, col = as.factor(tps))) +
  geom_point() +
  stat_smooth() +
  facet_wrap(~ns)


sim_byprop_1 <- sim_byprop


```













```{r}

true_population_size <- 1e5
sample_size <- 100 # for now we fix this value
n_samples <- 10

for(seed in 1:100){
  
  if(seed == 1) gev_ests <- tibble()
  
  true_populations <- 
    tibble(x_norm = rnorm(n = true_population_size, mean = 50, sd = 50/3),
           x_lnorm = rlnorm(n = true_population_size))
  
  true_maximum <- 
    true_populations %>% 
    summarise(true_max_norm = max(x_norm), 
              true_max_lnorm = max(x_lnorm),
              true_p99_norm = quantile(x_norm, 0.99), 
              true_p99_lnorm = quantile(x_lnorm, 0.99),
              true_p95_norm = quantile(x_norm, 0.95), 
              true_p95_lnorm = quantile(x_lnorm, 0.95),
    )
  
  for(s in 1:n_samples){
    
    if(s==1) samples <- tibble()
    
    samples_current <- 
      tibble(x_norm = sample(x = true_populations$x_norm, 
                             size = sample_size,
                             replace = FALSE),
             x_lnorm = sample(x = true_populations$x_lnorm, 
                              size = sample_size,
                              replace = FALSE)) %>% 
      mutate(sample_id = s)
    
    
    samples <- 
      bind_rows(
        samples, 
        samples_current
      )
  }
  
  
  sample_maxima <- 
    samples %>%
    summarise(sample_max_norm = max(x_norm),
              sample_max_lnorm = max(x_lnorm), 
              .by = sample_id)
  
  gev_fit <- 
    sample_maxima %>% 
    mutate(seed = seed) %>% 
    nest(.by = seed) %>% 
    mutate(gev_fit_norm = map(.x = data, 
                              .f = ~evd::fgev(.x$sample_max_norm, std.err = FALSE)), 
           loc_norm = map_dbl(.x = gev_fit_norm,
                              .f = ~.x$estimate["loc"]),
           scale_norm = map_dbl(.x = gev_fit_norm,
                                .f = ~.x$estimate["scale"]),
           shape_norm = map_dbl(.x = gev_fit_norm,
                                .f = ~.x$estimate["shape"]),
           gev_fit_lnorm = map(.x = data, 
                               .f = ~evd::fgev(.x$sample_max_lnorm, std.err = FALSE)), 
           loc_lnorm = map_dbl(.x = gev_fit_lnorm,
                               .f = ~.x$estimate["loc"]),
           scale_lnorm = map_dbl(.x = gev_fit_lnorm,
                                 .f = ~.x$estimate["scale"]),
           shape_lnorm = map_dbl(.x = gev_fit_lnorm,
                                 .f = ~.x$estimate["shape"])) 
  gev_ests_current <-
    gev_fit %>% 
    bind_cols(true_maximum) %>% 
    mutate(sample_size = sample_size, 
           true_population_size = true_population_size)
  
  gev_ests <- 
    bind_rows(
      gev_ests,
      gev_ests_current
    )
  
}

gev_ests %>% 
  ggplot(aes(loc_norm, true_p99_norm)) +
  geom_point()

ci_gev_ests <- 
  gev_ests %>% 
  select(seed, loc_norm, scale_norm, shape_norm) %>% 
  # filter(seed == 1) %>%
  expand_grid(x = seq(0, 
                      5, 
                      by = 0.001)) %>% 
  rowwise() %>%
  mutate(y = pgev(q = x, 
                  loc = loc_norm, 
                  scale = scale_norm,
                  shape = shape_norm)) %>% 
  ungroup() %>% 
  summarise(
    median = quantile(y, p = 0.5),
    lower = quantile(y, p = 0.025),
    upper = quantile(y, p = 0.975), 
    .by = x
  )

# gev_ests %>% 
#   rowwise() %>%
#   mutate(percentile = pgev(q = true_max_norm, 
#                            loc = loc_norm, 
#                            scale = scale_norm,
#                            shape = shape_norm)) %>% 
#   ggplot(aes(percentile)) +
#   geom_density()

l_m <- 
  gev_ests %>% 
  filter(seed == 1) %>% 
  unnest(data) %>% 
  pull(sample_max_norm)

l_m_tbl <- 
  tibble(l_m = l_m) %>% 
  mutate(rank = rank(l_m)) %>% 
  mutate(pos = rank/(max(rank)+1))


ci_gev_ests %>% 
  ggplot(aes(x = x, 
             y = median,
             group = seed)) +
  geom_line() +
  geom_line(lty = 2, 
            aes(y = lower)) +
  geom_line(lty = 2, 
            aes(y = upper)) +
  geom_vline(xintercept = gev_ests %>% filter(seed == 1) %>% pull(true_max_norm), 
             col = "red") +
  geom_vline(xintercept = gev_ests %>% filter(seed == 1) %>% pull(true_p99_norm), 
             col = "green") +
  geom_vline(xintercept = gev_ests %>% filter(seed == 1) %>% pull(true_p95_norm), 
             col = "blue") +
  geom_hline(yintercept = 1-(1/n_samples)) +
  theme_classic(20)

pgev(q = seed1_fit$true_max_norm,
     loc = seed1_fit$loc_norm,
     scale = seed1_fit$scale_norm,
     shape = seed1_fit$scale_norm)

0.9997314/(1-0.9997314)

```

# Simulation

```{r}

sim_input <- 
  tibble(true_population_size = c(1e5, 1e6)) %>% 
  expand_grid(sample_size_proportion = c(0.01, 0.02, 0.03, 0.04)) %>% 
  mutate(sample_size = round(sample_size_proportion*true_population_size)) %>% 
  expand_grid(n_samples = c(5, 10, 15, 20, 30, 40, 50)) %>% 
  rowid_to_column(var = "sim_id") %>% 
  expand_grid(seed = 1:40)

seed_sample <- function(seed, x, n, replace = FALSE){
  set.seed(seed)
  sample(x = x, size = n, replace = replace)
}

try_evd_fit <- function(x, se = FALSE) {
  suppressWarnings(try(evd::fgev(x = x, 
                                 std.err = se),
                       silent = TRUE))
}


sim_input %>%
  uncount(n_samples) %>% 
  partition(cluster) %>% 
  mutate(true_population = map(true_population_size, 
                               ~rnorm(n = ., mean = 50, sd = 50/3))) 

library(multidplyr)
cluster <- new_cluster(4)
cluster_library(cluster, "purrr")
xx <-
  sim_input %>%
  uncount(n_samples) %>% 
  partition(cluster) %>% 
  mutate(true_population = map(true_population_size, 
                               ~rnorm(n = ., mean = 50, sd = 50/3))) %>% 
  mutate(true_max = map_dbl(.x = true_population, 
                            .f = max), 
         true_p99 = map_dbl(.x = true_population, 
                            .f = ~quantile(.x, 0.99))) %>% 
  # expand_grid(seed = 1:10) %>% 
  mutate(sample_population = map2(.x = true_population, .y = sample_size, 
                                  .f = ~sample(x = .x, size = .y))) %>% 
  mutate(sample_max = map_dbl(.x = sample_population, 
                              .f = max))  

true_vals <- 
  xx %>% 
  select(sim_id, 
         true_max, 
         true_p99) %>% 
  distinct()


out <- 
  xx %>% 
  select(sim_id, sample_max) %>% 
  nest(.by = sim_id) %>% 
  mutate(gev.try = map(.x = data, 
                       .f = ~try_evd_fit(x = .x$sample_max))) %>% 
  mutate(gev.convergence = map_chr(.x = gev.try, 
                                   .f = ~.x$convergence),
         loc = map_dbl(.x = gev.try, 
                       .f = ~.x$estimate["loc"]),
         scale = map_dbl(.x = gev.try, 
                         .f = ~.x$estimate["scale"]),
         shape = map_dbl(.x = gev.try, 
                         .f = ~.x$estimate["shape"])) %>% 
  left_join(sim_input) %>% 
  left_join(true_vals) 

out %>% 
  filter(gev.convergence == "successful") %>% 
  rowwise() %>% 
  mutate(expected = loc + (scale / shape) * (gamma(1 - shape) - 1), 
         p99 = qgev(p = 0.99, loc = loc, scale = scale, shape = shape)) %>% 
  ggplot(aes(p99, true_max, col = n_samples)) +
  geom_point() +
  geom_abline(slope = 1)

for(sim in 1:nrow(sim_input)){
  if(sim == 1) out_tbl <- tibble()
  
  
  test <- sim_input[sim,]
  
  for(seed1 in 1:100){
    
    
    set.seed(seed1)
    
    true_population <- rnorm(n = test$true_population_size, 
                             mean = 50, 
                             sd = 50/3)
    
    true_max <- max(true_population)
    true_p99 <- quantile(true_population, 0.99)
    
    for(seed2 in 1:test$n_samples){
      if(seed2 == 1) sample_maxima <- c()
      
      sample_maxima <- 
        c(
          sample_maxima,
          max(sample(true_population, test$sample_size))
        )
    }
    
    gev.res <- try(evd::fgev(x = maxima, 
                             std.err = TRUE),
                   silent = TRUE)
    
    
    gev.error <- sum(class(gev.res) == "try-error")
    if(n_samples >= 10){
      
      if(gev.error == 0){
        model_used <- "GEV distribution with SE"
        gev_fit <- gev.res
        gev_shape = gev_fit$estimate[3]
        gev_shape_se = gev_fit$std.err[3]
      } 
    }
    if(n_samples < 10 | gev.error){
      
      # Try fitting Gumbel
      gum.res <- try(evd::fgev(x = maxima, 
                               shape = 0, # force gumbel
                               std.err = TRUE),
                     silent = TRUE)
      gum.error <- sum(class(gum.res) == "try-error")
      if(gum.error == 0){
        model_used <- "Gumbel distribution with SE"
        gev_fit <- gum.res
        gev_shape = 0
        gev_shape_se = 0
      } else {
        model_used <- "Gumbel distribution without SE"
        # Fit Gumbel without std.err
        gev_fit <- evd::fgev(x = maxima, 
                             shape = 0, # force gumbel
                             std.err = FALSE)
        gev_shape = 0
        gev_shape_se = 0
      }
    }
    
    
    out_tbl <- 
      bind_rows(
        out_tbl,
        tibble(
          sim = sim,
          seed1 = seed1,
          true_max = true_max, 
          true_p99 = true_p99,
          model = model_used,
          loc = gev_fit$estimate["loc"],
          scale = gev_fit$estimate["scale"],
          shape = gev_shape,
          loc_se = gev_fit$std.err["loc"],
          scale_se = gev_fit$std.err["scale"],
          shape_se = gev_shape_se
        )
      )
    
  }
  
}


## I have ran all these simulations on Nectar - file out_tbl saved as "simulation_output.csv"


```






```{r evt_calc}


# Empirical CDF
ecdf_func <- function(data) { 
  Length <- length(data) 
  sorted <- sort(data) 
  
  ecdf <- rep(0, Length) 
  for (i in 1:Length) { 
    ecdf[i] <- sum(sorted <= data[i]) / Length 
  } 
  return(ecdf) 
} 

calc_lmax <- function(maxima){
  
  raw_data <- 
    tibble(maxima = maxima) %>% 
    mutate(rank = rank(maxima)) %>% 
    arrange(rank) %>% 
    mutate(m = rank/max(rank+1)) %>% 
    mutate(ecdf = ecdf_func(maxima))
  
  
  
  n_samples <- length(maxima)
  
  if(n_samples < 3){
    return("Needs more than two maxima values")
  }
  
  # Try fitting GEV
  gev.res <- try(evd::fgev(x = maxima, 
                           std.err = TRUE),
                 silent = TRUE)
  gev.error <- sum(class(gev.res) == "try-error")
  if(n_samples >= 10){
    
    if(gev.error == 0){
      model_used <- "GEV distribution with SE"
      gev_fit <- gev.res
      gev_shape = gev_fit$estimate[3]
      gev_shape_se = gev_fit$std.err[3]
    } 
  }
  if(n_samples < 10 | gev.error){
    
    # Try fitting Gumbel
    gum.res <- try(evd::fgev(x = maxima, 
                             shape = 0, # force gumbel
                             std.err = TRUE),
                   silent = TRUE)
    gum.error <- sum(class(gum.res) == "try-error")
    if(gum.error == 0){
      model_used <- "Gumbel distribution with SE"
      gev_fit <- gum.res
      gev_shape = 0
      gev_shape_se = 0
    } else {
      model_used <- "Gumbel distribution without SE"
      # Fit Gumbel without std.err
      gev_fit <- evd::fgev(x = maxima, 
                           shape = 0, # force gumbel
                           std.err = FALSE)
      gev_shape = 0
      gev_shape_se = 0
    }
  }
  
  
  
  # print(paste(n_samples, "maxima fit using the", model_used))
  
  gev_location = gev_fit$estimate[1]
  gev_scale = gev_fit$estimate[2]
  
  gev_location_se = gev_fit$std.err[1]
  gev_scale_se = gev_fit$std.err[2]
  
  out <- qgev(max(raw_data$m), gev_location, gev_scale, gev_shape)
  out_lwr <- qgev(max(raw_data$m), 
                  gev_location - gev_location_se, 
                  gev_scale - gev_location_se, 
                  gev_shape - gev_shape_se)
  out_upr <- qgev(max(raw_data$m), 
                  gev_location + gev_location_se, 
                  gev_scale + gev_location_se, 
                  gev_shape + gev_shape_se)
  
  tibble(max_rank = max(raw_data$m), 
         fit = out, 
         lwr = out_lwr, 
         upr = out_upr)
}



```


```{r evt_plot}



if(length(l_m) >= 10){
  gev_fit <- evd::fgev(x = l_m, 
                       std.err = TRUE)
  gev_shape = gev_fit$estimate[3]
  gev_shape_se = gev_fit$std.err[3]
} else {
  gev_fit <- evd::fgev(x = l_m, 
                       shape = 0, # force gumbel
                       std.err = TRUE)
  gev_shape = 0
  gev_shape_se = 0
}

gev_location = gev_fit$estimate[1]
gev_scale = gev_fit$estimate[2]

gev_location_se = gev_fit$std.err[1]
gev_scale_se = gev_fit$std.err[2]

output <- calc_lmax(l_m)


evt_table <- 
  tibble(l = seq(0, max(l_m)*3, by = 0.001)) %>% 
  rowwise() %>% 
  mutate(gev = pgev(l, gev_location, gev_scale, gev_shape), 
         gev_lwr = pgev(l, 
                        gev_location - gev_location_se, 
                        gev_scale - gev_location_se, 
                        gev_shape - gev_shape_se),
         gev_upr = pgev(l, 
                        gev_location + gev_location_se, 
                        gev_scale + gev_location_se, 
                        gev_shape + gev_shape_se)) 

# fig_evt <- 
evt_table %>%
  ggplot(aes(x = l, y = gev)) +
  geom_segment(y = -Inf, yend = output$max_rank, x = output$fit, xend = output$fit, col = "grey") +
  geom_segment(y = -Inf, yend = output$max_rank, x = output$lwr, xend = output$lwr, col = "grey", lty = 2) +
  geom_segment(y = -Inf, yend = output$max_rank, x = output$upr, xend = output$upr, col = "grey", lty = 2) +
  geom_segment(y = output$max_rank, yend = output$max_rank, x = -Inf, xend = output$upr, col = "grey") +
  geom_line() +
  geom_line(aes(y = gev_lwr), col = "red", lty = 2) +
  geom_line(aes(y = gev_upr), col = "red", lty = 2) +
  geom_point(aes(x = l_m, y = pos),
             data = l_m_tbl) +
  labs(x = "Body length, cm", 
       y = "Probability density") +
  theme_classic(20)

```


# Changing the sample size of the initial distribution 

Larger sample sizes allow for detection of larger maxima. However the relationship between sample size and observed maxima is dependant on the underlying distribution. 

The question that remains: does the underlying distribution influence the relationship between the observed maxima and the estimated maxima?


```{r}

set.seed(1)

n_populations <- 1000

pop_size <- 
  tibble(sample_number = 1:n_populations) %>%
  mutate(population_size = rlnorm(n_populations, meanlog = 4, sdlog = 3) %>% floor())

sim_tbl <- 
  pop_size %>% 
  uncount(population_size) %>% 
  mutate(x_norm = rnorm(n = nrow(.)),
         x_lnorm = rlnorm(n = nrow(.)))

sample_maxima_bydist <- 
  sim_tbl %>% 
  summarise(sample_maxima_lnorm = max(x_lnorm),
            sample_maxima_norm = max(x_norm), 
            .by = sample_number) %>% 
  left_join(pop_size)

sample_maxima_bydist %>% 
  pivot_longer(cols = contains("sample_maxima")) %>% 
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(~name, scales = "free")

sample_maxima_bydist %>% 
  pivot_longer(cols = contains("sample_maxima")) %>% 
  ggplot(aes(x = log(population_size),
             y = value)) +
  geom_point() + 
  # stat_smooth()+
  facet_wrap(~name, scales = "free")

```

```{r}

for(seed in 1:100){
  
  if(seed == 1) out_multdists_all <- tibble()
  
  n_populations <- 1000
  
  pop_size <- 
    tibble(sample_number = 1:n_populations) %>%
    mutate(population_size = rlnorm(n_populations, meanlog = 4, sdlog = 3) %>% floor()) %>% 
    mutate(seed = seed) %>% 
    filter(population_size > 5)
  
  sim_tbl <- 
    pop_size %>% 
    uncount(population_size) %>% 
    mutate(x_norm = rnorm(n = nrow(.)),
           x_lnorm = rlnorm(n = nrow(.)))
  
  sample_maxima_bydist <- 
    sim_tbl %>% 
    summarise(sample_maxima_lnorm = max(x_lnorm),
              sample_maxima_norm = max(x_norm), 
              .by = c(seed, sample_number)) %>% 
    left_join(pop_size)
  
  out_multdists <- 
    sample_maxima_bydist %>% 
    nest(.by = seed) %>% 
    mutate(gev_fit_norm = map(.x = data, 
                              .f = ~evd::fgev(.x$sample_maxima_norm, std.err = FALSE)), 
           loc_norm = map_dbl(.x = gev_fit_norm,
                              .f = ~.x$estimate["loc"]),
           scale_norm = map_dbl(.x = gev_fit_norm,
                                .f = ~.x$estimate["scale"]),
           shape_norm = map_dbl(.x = gev_fit_norm,
                                .f = ~.x$estimate["shape"]),
           gev_fit_lnorm = map(.x = data, 
                               .f = ~evd::fgev(.x$sample_maxima_lnorm, std.err = FALSE)), 
           loc_lnorm = map_dbl(.x = gev_fit_lnorm,
                               .f = ~.x$estimate["loc"]),
           scale_lnorm = map_dbl(.x = gev_fit_lnorm,
                                 .f = ~.x$estimate["scale"]),
           shape_lnorm = map_dbl(.x = gev_fit_lnorm,
                                 .f = ~.x$estimate["shape"])) 
  out_multdists_all <- 
    bind_rows(
      out_multdists_all,
      out_multdists
    )
}

out_multdists_all %>% 
  select(seed, data) %>% unnest()

```

